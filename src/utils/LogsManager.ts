import {
	type ButtonInteraction,
	type CommandInteraction,
	EmbedBuilder,
	type GuildChannel,
	TextChannel,
	type StringSelectMenuInteraction,
	type Snowflake,
} from 'discord.js';
import discordTranscripts from 'discord-html-transcripts';
import type { Bot } from '../structures/index';
import { TicketManager } from './TicketManager';

// biome-ignore lint/complexity/noStaticOnlyClass: <explanation>
export class LogsManager {
	public static async logTicketCreation(
		interaction: CommandInteraction | ButtonInteraction,
		categoryLabel: string,
		client: Bot,
		ticketChannel: GuildChannel,
	): Promise<void> {
		await LogsManager.logTicketAction(interaction, client, ticketChannel, 'üéüÔ∏è Ticket Created', '#2FF200', categoryLabel);
	}

	public static async logTicketDeletion(
		interaction: CommandInteraction | ButtonInteraction,
		client: Bot,
		_userName: string,
		categoryLabel: string,
		ticketChannel: GuildChannel,
		reason: string,
	): Promise<void> {
		await LogsManager.logTicketAction(
			interaction,
			client,
			ticketChannel,
			'‚õî Ticket Closed',
			'#FF2400',
			categoryLabel,
			reason,
		);
	}

	public static async logTicketTranscript(
		interaction: CommandInteraction | ButtonInteraction,
		client: Bot,
		ticketChannel: GuildChannel,
	): Promise<void> {
		try {
			const { transcriptLogsChannelId } = await TicketManager.readConfigFile();
			const ticketInfo = await client.db.getTicketInfo(ticketChannel.id);
			const ticketCreator = ticketInfo?.creator ?? interaction.user.username;
			const transcriptLogsChannel = await LogsManager.getChannelById(client, transcriptLogsChannelId);

			const embed = LogsManager.createLogEmbed(
				interaction,
				ticketCreator,
				'#3498DB',
				'üìù Transcript Generated',
				LogsManager.createDescription(interaction, ticketCreator, ticketChannel, '', '', 'üìù Transcript Generated'),
			);

			await LogsManager.sendTranscript(transcriptLogsChannel, embed, ticketChannel as TextChannel, client);
		} catch (error) {
			client.logger.error('Failed to log ticket transcript:', error);
		}
	}

	public static async logTicketRating(
		interaction: CommandInteraction | ButtonInteraction | StringSelectMenuInteraction,
		client: Bot,
		ticketChannel: GuildChannel,
		rating: number,
		ratingLogChannelId: Snowflake,
	): Promise<void> {
		try {
			const ratingLogChannel = await LogsManager.getChannelById(client, ratingLogChannelId);
			const ticketInfo = await client.db.getTicketInfo(ticketChannel.id);
			const ticketCreator = ticketInfo?.creator ?? interaction.user.username;

			const embed = LogsManager.createLogEmbed(
				interaction,
				ticketCreator,
				'#F1C40F',
				'‚≠ê Ticket Rating',
				`- **Ticket:** \n> ${ticketChannel.toString()} \n> (${ticketChannel.name} - ID: ${ticketChannel.id})\n\n- **Rating:** \n> ${rating} stars`,
			);

			await ratingLogChannel.send({ embeds: [embed] });
		} catch (error) {
			client.logger.error('Failed to log ticket rating:', error);
		}
	}

	private static async logTicketAction(
		interaction: CommandInteraction | ButtonInteraction,
		client: Bot,
		ticketChannel: GuildChannel,
		title: string,
		color: string,
		categoryLabel = '',
		reason = '',
	): Promise<void> {
		try {
			const { enableTranscripts, transcriptLogsChannelId, logChannelId } = await TicketManager.readConfigFile();
			const logChannel = await LogsManager.getLogChannel(client);
			const ticketInfo = await client.db.getTicketInfo(ticketChannel.id);
			const ticketCreator = ticketInfo?.creator ?? interaction.user.username;

			const embed = LogsManager.createLogEmbed(
				interaction,
				ticketCreator,
				color,
				title,
				LogsManager.createDescription(interaction, ticketCreator, ticketChannel, categoryLabel, reason, title),
			);

			const targetChannelId = title === 'üìù Transcript Generated' ? transcriptLogsChannelId : logChannelId;
			const targetChannel = await LogsManager.getChannelById(client, targetChannelId);

			if (title === 'üìù Transcript Generated' || (title === '‚õî Ticket Closed' && enableTranscripts)) {
				await LogsManager.sendTranscript(targetChannel, embed, ticketChannel as TextChannel, client);
			} else {
				await logChannel.send({ embeds: [embed] });
			}
		} catch (error) {
			client.logger.error(`Failed to log ${title.toLowerCase()}:`, error);
		}
	}

	private static createDescription(
		interaction: CommandInteraction | ButtonInteraction,
		ticketCreator: string,
		ticketChannel: GuildChannel,
		categoryLabel: string,
		reason: string,
		title: string,
	): string {
		const baseDesc = `- **Ticket Creator:** \n> ${ticketCreator}\n\n- **Ticket:** \n> ${ticketChannel.toString()} \n> (${ticketChannel.name} - ID: ${ticketChannel.id})`;
		if (title === '‚õî Ticket Closed') {
			return `- **Closed By:** \n> ${interaction.user.username}\n\n${baseDesc}\n\n- **Category:** \n> ${categoryLabel}${reason ? `\n\n- **Reason:** \n> ${reason}` : ''}`;
		}
		if (title === 'üìù Transcript Generated') {
			return `- **Transcript Generated By:** \n> ${interaction.user.username}\n\n${baseDesc}`;
		}
		return `${baseDesc}\n\n- **Category:** \n> ${categoryLabel}`;
	}

	private static createLogEmbed(
		interaction: CommandInteraction | ButtonInteraction | StringSelectMenuInteraction,
		userName: string,
		color: string,
		title: string,
		description: string,
	): EmbedBuilder {
		return new EmbedBuilder()
			.setThumbnail(interaction.user.displayAvatarURL({ extension: 'png', size: 1024 }))
			.setAuthor({ name: title, iconURL: interaction.user.displayAvatarURL({ extension: 'png', size: 1024 }) })
			.setDescription(description)
			.setColor(color as any)
			.setFooter({
				text: `Action performed by ${userName}`,
				iconURL: interaction.user.displayAvatarURL({ extension: 'png', size: 1024 }),
			})
			.setTimestamp();
	}

	private static async getLogChannel(client: Bot): Promise<TextChannel> {
		const { logChannelId } = await TicketManager.readConfigFile();
		return LogsManager.getChannelById(client, logChannelId);
	}

	private static async getChannelById(client: Bot, channelId: string): Promise<TextChannel> {
		const channel = await client.channels.fetch(channelId);
		if (!(channel instanceof TextChannel)) throw new Error('Log channel not found or not a text channel');
		return channel;
	}

	private static async sendTranscript(
		logChannel: TextChannel,
		embed: EmbedBuilder,
		ticketChannel: TextChannel,
		client: Bot,
	): Promise<void> {
		try {
			const transcript = await discordTranscripts.createTranscript(ticketChannel);
			await logChannel.send({ embeds: [embed], files: [transcript] });
		} catch (error) {
			client.logger.error('Failed to create transcript:', error);
			await logChannel.send({ embeds: [embed], content: 'Failed to create transcript.' });
		}
	}
}
